[
{
	"uri": "https://frest.netlify.com/interceptor/concept/",
	"title": "Concept",
	"tags": [],
	"description": "",
	"content": " The Challenge When dealing with API call using fetch() there are often common task to perform for any or a subset of requests, such as:\n JSON stringify Request or parse Response body. Attaching authentication identifiers to the Request. Catch common error. Retrying the request with exponential back off.  Interceptor as Solution In Frest, Interceptor is a function invoked during the life cycle of a request. This function, depend on the life cycle it\u0026rsquo;s configured to, can modify/append/replace the original intended parameters.\nThere are 3 kind of Interceptor in Frest, along with some tasks that suit to put there\n Request Interceptor is invoked just before the request is sent to an API server.  Append common header JSON.stringify the body property of Request configuration if it\u0026rsquo;s a plain object Attach auth information Init logging  Response Interceptor is invoked after the response came from the server, but before returning it to the caller.  JSON.parse the body property of Response if the Content-Type is compatible with json Normalize the Response body Flush logging  Error Interceptor is invoked whenever there is an error happened, including Non OK HTTP Response status.  Giving a context to the error for debugging purpose Logging Retrying the request   "
},
{
	"uri": "https://frest.netlify.com/using-frest/",
	"title": "Using Frest",
	"tags": [],
	"description": "",
	"content": "  The Frest Instance Calling API Endpoint Response Processing Async Await Style Using TypeScript  After installation, import it your code. The Frest class is exported in default namespace\n1 2  import Frest from \u0026#39;frest\u0026#39;;    The Frest Instance Now we can create an instance to communicate with an API URL. Suppose we want to call an API with base URL https://api.example.com\n1 2  const api = new Frest(\u0026#39;https://api.example.com\u0026#39;);    If you are using the UMD build through a script tag, Frest class is available in global window and self object.\n We can also configure the instance with some default parameter, which will be applied to all API call. In this example, we want all request to append a header X-Foo with value bar\n1 2 3 4 5 6 7  const api = new Frest({ base: \u0026#39;https://api.example.com\u0026#39;, headers: new Headers({ \u0026#39;X-Foo\u0026#39;: \u0026#39;bar\u0026#39;, }), });    The configuration object generally extends fetch init parameter. Refer to Configuration page for more information of available properties\n Calling API Endpoint With the instance configured, we can now use its methods to call an API endpoint. With native fetch you have to provide {method: '\u0026lt;HTTP METHOD\u0026gt;'} to call endpoint with certain HTTP Method. In Frest it\u0026rsquo;s available directly as method in the instance.\nHere we want to call GET https://api.example.com/foo.\n1 2  api.get(\u0026#39;foo\u0026#39;).then(/*Do something with the response*/);    As with the native Fetch API, Frest also needs Promise to be available in the browser. If there is a browser of your target that doesn\u0026rsquo;t support Promise, you need to include a polyfill before importing Frest, e.g. es6-promise.\n Here is other available method of the instance, all correspond to HTTP Method as the name implies.\n1 2 3 4 5 6 7 8 9 10 11 12  api.post(...) // HTTP POST api.create(...) // alias of api.post api.read(...) // alias of api.get api.put(...) // HTTP PUT api.update(...) // alias of api.put api.delete(...) // HTTP DELETE api.destroy(...) // alias of api.delete api.patch(...) // HTTP PATCH api.option(...) // HTTP OPTION api.download(...) // Download file, support onDownloadProgress event api.upload(...) // Upload file, support onUploadProgress event    We can provide specific configuration to each request. It\u0026rsquo;ll be merged with the default configuration we specified in the instance. Here we set the X-Foo header for this specific request with foo value.\n1 2 3 4  api .get(\u0026#39;foo\u0026#39;, { headers: new Headers({ \u0026#39;X-Foo\u0026#39;: \u0026#39;foo\u0026#39; }) }) .then(/*Do something with the response*/);    Response Processing When the request is finished, the promise will be completed and we can do something with the response. The resolved value is an object of IResponse interface, contains origin property which is the original fetch Response, and the body if any. If there is any error during the request, we can catch it in the chain. The error is an instance of FrestError.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  api .get(\u0026#39;foo\u0026#39;, { headers: new Headers({ \u0026#39;X-Foo\u0026#39;: \u0026#39;foo\u0026#39; }) }) .then(res =\u0026gt; { const { origin, body } = res; console.log(\u0026#39;origin\u0026#39;, origin); console.log(\u0026#39;body\u0026#39;, body); // We can safely omit the origin.ok check because Frest took care of it.  // If origin.ok is false, it\u0026#39;ll be thrown as an error and caught in the catch block below  return origin.json(); }) .then(body =\u0026gt; { console.log(\u0026#39;body\u0026#39;, body); }) .catch(err =\u0026gt; { console.error(\u0026#39;request failed\u0026#39;, err); });    The body property above by default is undefined. It\u0026rsquo;s meant for response interceptors to process and put value in there.\nFor example, the above task of parsing application/json response can be repetitive and a suitable candidate to put in a response interceptor.\nIn fact, there is frest-json, an official interceptor package of Frest that do just that.\nFind out more about Interceptor Concept here.\n Async Await Style We can also use Frest api calling in async-await fashion.\n1 2 3 4 5 6 7 8 9 10 11 12  async function makeRequest() { try { const {origin} = await api.post(\u0026#39;blah\u0026#39;); if (origin.ok) { const body = await origin.json(); console.log(\u0026#39;body\u0026#39;, body); } } catch (err) { console.error(\u0026#39;request failed\u0026#39;, err); } }    Using TypeScript Frest is developed with TypeScript and include its own definition files. We can comfortably import Frest and use the awesomeness of TypeScript altogether :)\n"
},
{
	"uri": "https://frest.netlify.com/interceptor/",
	"title": "Interceptor",
	"tags": [],
	"description": "",
	"content": " Interceptor Learn to use interceptor for Frest instances.\n"
},
{
	"uri": "https://frest.netlify.com/interceptor/using-interceptor/",
	"title": "Using Interceptor",
	"tags": [],
	"description": "",
	"content": "  Creating Interceptor  Request Interceptor Response Interceptor Error Interceptor  Add/Remove Interceptor Order of Execution  Creating Interceptor As mentioned earlier interceptors are function. They will be called with some parameters and can return their modified values.\nTo better demonstrate it, let\u0026rsquo;s create each type of interceptor as examples.\nRequest Interceptor Suppose we want to create a request interceptor with these requirements\n Set Content-Type header to application/json value if the body is a plain object and called with POST HTTP method. Set Accept headers as application/json for all requests.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  const jsonRequestInterceptor = ({ frest, request }) =\u0026gt; // 1  new Promise((resolve, reject) =\u0026gt; { // 2  const { body, headers, method } = request; headers.set(\u0026#39;Accept\u0026#39;, \u0026#39;application/json\u0026#39;); // 3  try { if (typeof body === \u0026#39;object\u0026#39; \u0026amp;\u0026amp; method === \u0026#39;POST\u0026#39;) { const newBody = JSON.stringify(body); headers.set(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/json\u0026#39;); // 3  resolve({ ...request, headers, body: newBody }); // 4  return; } resolve({..request, headers}); } catch (e) { reject(e); } }); jsonRequestInterceptor.id = \u0026#39;json:request\u0026#39;;    Some important points from above example\n The request interceptor function will receive 1 object args with 2 properties:  frest is the Frest instance which call this interceptor request is the original request state before it enters this interceptor TODO  The request interceptor must return a Promise We can modify the request as we need, in this case we\u0026rsquo;re adding some headers resolve the Promise with new request configuration. We can also resolve it to the original request, which means there is no modification to the request.  What\u0026rsquo;s the implication if we use this interceptor?\n No need to manually stringify request body to JSON string in every request No need to append necessary headers in every request  Response Interceptor Now we\u0026rsquo;ll look at how to create a response interceptor. We\u0026rsquo;ll use the same case around json like the request interceptor part.\n Parse response body if the response Content-Type is compatible with application/json But also check before hand whether the fetch Response bodyUsed is false.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  const jsonResponseInterceptor = ({ frest, request, response }) =\u0026gt; // 1  new Promise((resolve, reject) =\u0026gt; { // 2  const { origin, body } = response; // 3  const { headers, bodyUsed } = origin; const contentType = headers.get(\u0026#39;Content-Type\u0026#39;); if ( !bodyUsed \u0026amp;\u0026amp; // 4  contentType \u0026amp;\u0026amp; contentType.indexOf(\u0026#39;application/json\u0026#39;) \u0026gt;= 0 ) { origin .json() .then(responseBody =\u0026gt; { resolve({ origin, body: responseBody }); // 5  }) .catch(reject); return; } resolve(response); // 6  }); jsonResponseInterceptor.id = \u0026#39;json:response\u0026#39;;    Some important points from above example\n The response interceptor function will receive 1 object args with 3 properties:  frest same as request interceptor request same as request interceptor response the Frest response  Same as request interceptor, response interceptor also must return Promise. The response is an object which contains properties:  origin the original fetch Response instance body parsed value of the response body. It\u0026rsquo;s response interceptor which will fill this value.  We must check the state of body whether it\u0026rsquo;s already drained or not. Resolve the promise with new Frest response object. We must always include the original fetch Response instance as origin property. The body value is the parsed JSON response. We can also resolve with the original Frest response object, which means there is no modification in this interceptor.  What\u0026rsquo;s the implication if we use this interceptor?\n No need to manually parse response in every successful request. The value is now available directly in Frest Response.body  Error Interceptor In Frest any non OK response (status outside 2xx) will result in a thrown error. This is useful so we can have a common place to check for error (instead of checking ok property in fetch response).\nLet\u0026rsquo;s look at how we implement error interceptor. Since we have created request and response interceptor to deal with JSON data, we\u0026rsquo;ll also create an interceptor to parse non OK response, if any. The tasks are\n Parse response body if the response Content-Type is compatible with application/json  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  const jsonErrorInterceptor = err =\u0026gt; // 1  new Promise((resolve, reject) =\u0026gt; { // 2  const {frest, request, response} = err; // 3  if (response) { // 4  const { headers, bodyUsed } = response.origin; const contentType = headers.get(\u0026#39;Content-Type\u0026#39;); if ( !bodyUsed \u0026amp;\u0026amp; // 5  contentType \u0026amp;\u0026amp; contentType.indexOf(\u0026#39;application/json\u0026#39;) \u0026gt;= 0 ) { response.origin.json().then(body =\u0026gt; { response.body = body; err.response = response; reject(err); // 6  }); return; } } resolve(); // 7  })    Some important points from above example\n The error interceptor will receive 1 error arg which is an instance of FrestError As with other interceptor, error interceptor must return a Promise The FrestError instance will have these properties  frest same as other interceptor request same as other interceptor response same as response interceptor  The response property can be undefined, if the error happened before the request is sent Same with response interceptor, we have to check bodyUsed if we want to parse the response body In error interceptor, the promise must be rejected if we want to modify the error thrown. If we resolve the promise like this, then it means the original error is not modified.  If we want to recover from an error, instead of rejecting the returned promise, we can resolve it with another response. Suppose we want to make another request to retry with different config\n1 2 3 4  ... frest.request(request).then(resolve); ...    In above example, frest an request are the properties of FrestError in the interceptor arg. They refer to the same Frest instance and request config when we make the request. If the retry request is successful, Frest will recover with the resulting response and the error will not be thrown.\nThose 3 interceptor type examples above are already implemented in the official frest-json package. Check out the documentation of how to use it.\n Add/Remove Interceptor We can add/remove interceptors to Frest instance using either configuration in constructor or calling add[Type]Interceptor and remove[Type]Interceptor method.\nTo add them when creating Frest instance:\n1 2 3 4 5 6 7 8 9  const api = new Frest({ ...otherConfig, interceptors: { request: [...], response: [...], error: [...], } });    To add/remove them using methods of Frest instance:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  const api = new Frest(\u0026#39;\u0026#39;); api.addRequestInterceptor(...); api.addResponseInterceptor(...); api.addErrorInterceptor(...); api.removeRequestInterceptor(...); api.removeResponseInterceptor(...); api.removeErrorInterceptor(...); api.addInterceptors({ request: someRequestInterceptor, response: someResponseInterceptor, error: someErrorInterceptor, })    By convention, interceptors should have a unique identifier, assigned in the function itself (see above examples of creating interceptors). So we can also remove an interceptor using its id.\nSuppose we want to remove jsonRequestInterceptor created in example above, we can do it like so\n1 2  api.removeRequestInterceptor(\u0026#39;json:request\u0026#39;);    Order of Execution As we can see in ways of adding interceptors above, the interceptors are stored as array depending on their type. When there are multiple interceptors with the same type, they\u0026rsquo;ll be executed in the order of when they\u0026rsquo;re added.\n1 2 3 4 5 6 7 8 9 10 11  const api = new Frest({ ...otherConfig, interceptors: { request: [interceptor1, interceptor2], } }); ... api.addRequestInterceptor(interceptor3);    In above example, interceptor1 will be called first. The returned request, if any, from interceptor1 will be passed down to interceptor2. It\u0026rsquo;s the same way with interceptor3.\nThis is why we must always check the bodyUsed property of fetch Response, in the case of response interceptor. The body could have been used/read in other response interceptor, by the time it arrives in our interceptor.\n"
},
{
	"uri": "https://frest.netlify.com/api/",
	"title": "API Reference",
	"tags": [],
	"description": "",
	"content": " frest module API Reference frest-json module API Reference  "
},
{
	"uri": "https://frest.netlify.com/interceptor/available-interceptor/",
	"title": "Available Interceptor",
	"tags": [],
	"description": "",
	"content": " This is the list of available interceptors as of this writing\nOfficial Interceptor These interceptors are part of Frest source. They are distributed in their own package, so we have to explicitly install them if we want to use them.\n frest-json, a set of configurable interceptors to deal with JSON data. frest-auth, a request interceptor to deal with attaching auth info to the request.  Community Interceptor Please make a pull request to include yours here :) (Click the Edit this page link above for easy way)\n"
},
{
	"uri": "https://frest.netlify.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://frest.netlify.com/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Frest JavaScript REST Client Documentation in progress! Keep track at the pull request link\n Installation To install the core Frest package\n1 2 3 4  # using npm. -P is alias of --save-prod in NPM 5.x. Alternatively use --save npm i -P frest # using yarn yarn add frest   Or include the UMD build directly in a script tag\n1  \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://unpkg.com/frest\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   To install official interceptors\n1  yarn add frest-json frest-auth   TODO: More on interceptors\n Introduction Frest is a Browser REST client wrapper of Fetch API with XHR fallback and interceptor support.\nFeatures  HTTP methods shortcut and CRUD aliases XMLHttpRequest fallback, for file download/upload (with progress event) and when Fetch API is not available Interceptors to manipulate request/response/error:  Before request, add additional config for all/some operation before firing the request After response, transform response before returning for all/some operation Error, catch all error / request retry possibility  Include UMD build for direct usage in html script tag Include TypeScript definition  "
},
{
	"uri": "https://frest.netlify.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]